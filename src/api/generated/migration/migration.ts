/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * YRC Race API
 * Ïó¨ÏùòÎèÑ Îü¨Îãù ÌÅ¨Î£® ÎßàÎùºÌÜ§ Í∏∞Î°ù API
 * OpenAPI spec version: v1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  FindBibByHashParams,
  FindRaceMemberByBibParams,
  TestEncryptParams,
  TestHashParams
} from '../../models';

import { customInstance } from '../../../lib/api-client';




/**
 * Î™®Îì† RaceMemberÏùò encrypted_image_pathÏôÄ encrypted_thumbnail_pathÍ∞Ä Ïò¨Î∞îÎ•¥Í≤å ÏïîÌò∏ÌôîÎêòÏóàÎäîÏßÄ Í≤ÄÏ¶ùÌï©ÎãàÎã§.
 * @summary RaceMember Ïù¥ÎØ∏ÏßÄ Í≤ΩÎ°ú ÏïîÌò∏Ìôî Í≤ÄÏ¶ù
 */
export const verifyRaceMemberImages = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/admin/migration/verify-race-member-images`, method: 'POST', signal
    },
      );
    }
  


export const getVerifyRaceMemberImagesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyRaceMemberImages>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof verifyRaceMemberImages>>, TError,void, TContext> => {

const mutationKey = ['verifyRaceMemberImages'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyRaceMemberImages>>, void> = () => {
          

          return  verifyRaceMemberImages()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyRaceMemberImagesMutationResult = NonNullable<Awaited<ReturnType<typeof verifyRaceMemberImages>>>
    
    export type VerifyRaceMemberImagesMutationError = unknown

    /**
 * @summary RaceMember Ïù¥ÎØ∏ÏßÄ Í≤ΩÎ°ú ÏïîÌò∏Ìôî Í≤ÄÏ¶ù
 */
export const useVerifyRaceMemberImages = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyRaceMemberImages>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof verifyRaceMemberImages>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getVerifyRaceMemberImagesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Î™®Îì† ÌöåÏõêÏùò memberNameÏù¥ Ïò¨Î∞îÎ•¥Í≤å ÏïîÌò∏ÌôîÎêòÏóàÎäîÏßÄ Í≤ÄÏ¶ùÌï©ÎãàÎã§.
 * @summary ÏïîÌò∏Ìôî Í≤ÄÏ¶ù
 */
export const verifyEncryption = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/admin/migration/verify-encryption`, method: 'POST', signal
    },
      );
    }
  


export const getVerifyEncryptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyEncryption>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof verifyEncryption>>, TError,void, TContext> => {

const mutationKey = ['verifyEncryption'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyEncryption>>, void> = () => {
          

          return  verifyEncryption()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyEncryptionMutationResult = NonNullable<Awaited<ReturnType<typeof verifyEncryption>>>
    
    export type VerifyEncryptionMutationError = unknown

    /**
 * @summary ÏïîÌò∏Ìôî Í≤ÄÏ¶ù
 */
export const useVerifyEncryption = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyEncryption>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof verifyEncryption>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getVerifyEncryptionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * race_course_zonesÏùò ÏúÑÍ≤ΩÎèÑ Îç∞Ïù¥ÌÑ∞Î•º marathon_gps_infosÏóêÏÑú Í∞ÄÏ†∏ÏôÄ ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
 * @summary RaceCourseZone ÏúÑÍ≤ΩÎèÑ ÏóÖÎç∞Ïù¥Ìä∏ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
 */
export const updateRaceCourseZoneCoordinates = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/admin/migration/update-race-course-zone-coordinates`, method: 'POST', signal
    },
      );
    }
  


export const getUpdateRaceCourseZoneCoordinatesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRaceCourseZoneCoordinates>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateRaceCourseZoneCoordinates>>, TError,void, TContext> => {

const mutationKey = ['updateRaceCourseZoneCoordinates'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRaceCourseZoneCoordinates>>, void> = () => {
          

          return  updateRaceCourseZoneCoordinates()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRaceCourseZoneCoordinatesMutationResult = NonNullable<Awaited<ReturnType<typeof updateRaceCourseZoneCoordinates>>>
    
    export type UpdateRaceCourseZoneCoordinatesMutationError = unknown

    /**
 * @summary RaceCourseZone ÏúÑÍ≤ΩÎèÑ ÏóÖÎç∞Ïù¥Ìä∏ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
 */
export const useUpdateRaceCourseZoneCoordinates = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRaceCourseZoneCoordinates>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRaceCourseZoneCoordinates>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getUpdateRaceCourseZoneCoordinatesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Î™®Îì† RaceMemberÏùò encrypted_image_pathÏôÄ encrypted_thumbnail_pathÎ•º ÏÉàÎ°úÏö¥ AES ÏïîÌò∏Ìôî Î∞©ÏãùÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
 * @summary RaceMember Ïù¥ÎØ∏ÏßÄ Í≤ΩÎ°ú ÏïîÌò∏Ìôî ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
 */
export const encryptRaceMemberImages = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/admin/migration/encrypt-race-member-images`, method: 'POST', signal
    },
      );
    }
  


export const getEncryptRaceMemberImagesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof encryptRaceMemberImages>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof encryptRaceMemberImages>>, TError,void, TContext> => {

const mutationKey = ['encryptRaceMemberImages'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof encryptRaceMemberImages>>, void> = () => {
          

          return  encryptRaceMemberImages()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EncryptRaceMemberImagesMutationResult = NonNullable<Awaited<ReturnType<typeof encryptRaceMemberImages>>>
    
    export type EncryptRaceMemberImagesMutationError = unknown

    /**
 * @summary RaceMember Ïù¥ÎØ∏ÏßÄ Í≤ΩÎ°ú ÏïîÌò∏Ìôî ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
 */
export const useEncryptRaceMemberImages = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof encryptRaceMemberImages>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof encryptRaceMemberImages>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getEncryptRaceMemberImagesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * ÏßÄÏ†ïÎêú race_member_idÎì§Ïùò encrypted_image_pathÏôÄ encrypted_thumbnail_pathÎ•º ÏÉàÎ°úÏö¥ AES ÏïîÌò∏Ìôî Î∞©ÏãùÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
 * @summary ÏÑ†ÌÉùÏ†Å RaceMember Ïù¥ÎØ∏ÏßÄ Í≤ΩÎ°ú ÏïîÌò∏Ìôî ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
 */
export const encryptRaceMemberImagesSelective = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/admin/migration/encrypt-race-member-images-selective`, method: 'POST', signal
    },
      );
    }
  


export const getEncryptRaceMemberImagesSelectiveMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof encryptRaceMemberImagesSelective>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof encryptRaceMemberImagesSelective>>, TError,void, TContext> => {

const mutationKey = ['encryptRaceMemberImagesSelective'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof encryptRaceMemberImagesSelective>>, void> = () => {
          

          return  encryptRaceMemberImagesSelective()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EncryptRaceMemberImagesSelectiveMutationResult = NonNullable<Awaited<ReturnType<typeof encryptRaceMemberImagesSelective>>>
    
    export type EncryptRaceMemberImagesSelectiveMutationError = unknown

    /**
 * @summary ÏÑ†ÌÉùÏ†Å RaceMember Ïù¥ÎØ∏ÏßÄ Í≤ΩÎ°ú ÏïîÌò∏Ìôî ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
 */
export const useEncryptRaceMemberImagesSelective = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof encryptRaceMemberImagesSelective>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof encryptRaceMemberImagesSelective>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getEncryptRaceMemberImagesSelectiveMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Î™®Îì† ÌöåÏõêÏùò oriMemberNameÏùÑ ÏïîÌò∏ÌôîÌïòÏó¨ memberNameÏóê ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
 * @summary ÌöåÏõê Ïù¥Î¶Ñ ÏïîÌò∏Ìôî ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
 */
export const encryptMemberNames = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/admin/migration/encrypt-member-names`, method: 'POST', signal
    },
      );
    }
  


export const getEncryptMemberNamesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof encryptMemberNames>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof encryptMemberNames>>, TError,void, TContext> => {

const mutationKey = ['encryptMemberNames'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof encryptMemberNames>>, void> = () => {
          

          return  encryptMemberNames()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EncryptMemberNamesMutationResult = NonNullable<Awaited<ReturnType<typeof encryptMemberNames>>>
    
    export type EncryptMemberNamesMutationError = unknown

    /**
 * @summary ÌöåÏõê Ïù¥Î¶Ñ ÏïîÌò∏Ìôî ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
 */
export const useEncryptMemberNames = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof encryptMemberNames>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof encryptMemberNames>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getEncryptMemberNamesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * ÌäπÏ†ï Î∞∞Î≤àÏùò Ìï¥ÏãúÍ∞íÏùÑ ÏÉùÏÑ±ÌïòÏó¨ ÎπÑÍµêÌï©ÎãàÎã§.
 * @summary Ìï¥Ïãú ÌÖåÏä§Ìä∏
 */
export const testHash = (
    params: TestHashParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/admin/migration/test-hash`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getTestHashQueryKey = (params?: TestHashParams,) => {
    return [
    `/api/v1/admin/migration/test-hash`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getTestHashQueryOptions = <TData = Awaited<ReturnType<typeof testHash>>, TError = unknown>(params: TestHashParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testHash>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTestHashQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof testHash>>> = ({ signal }) => testHash(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof testHash>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TestHashQueryResult = NonNullable<Awaited<ReturnType<typeof testHash>>>
export type TestHashQueryError = unknown


export function useTestHash<TData = Awaited<ReturnType<typeof testHash>>, TError = unknown>(
 params: TestHashParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof testHash>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof testHash>>,
          TError,
          Awaited<ReturnType<typeof testHash>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestHash<TData = Awaited<ReturnType<typeof testHash>>, TError = unknown>(
 params: TestHashParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testHash>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof testHash>>,
          TError,
          Awaited<ReturnType<typeof testHash>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestHash<TData = Awaited<ReturnType<typeof testHash>>, TError = unknown>(
 params: TestHashParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testHash>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ìï¥Ïãú ÌÖåÏä§Ìä∏
 */

export function useTestHash<TData = Awaited<ReturnType<typeof testHash>>, TError = unknown>(
 params: TestHashParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testHash>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTestHashQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÌäπÏ†ï Î¨∏ÏûêÏó¥ÏùÑ ÏïîÌò∏ÌôîÌïòÍ≥† Î≥µÌò∏ÌôîÌï©ÎãàÎã§.
 * @summary ÏïîÌò∏Ìôî ÌÖåÏä§Ìä∏
 */
export const testEncrypt = (
    params: TestEncryptParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/admin/migration/test-encrypt`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getTestEncryptQueryKey = (params?: TestEncryptParams,) => {
    return [
    `/api/v1/admin/migration/test-encrypt`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getTestEncryptQueryOptions = <TData = Awaited<ReturnType<typeof testEncrypt>>, TError = unknown>(params: TestEncryptParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testEncrypt>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTestEncryptQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof testEncrypt>>> = ({ signal }) => testEncrypt(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof testEncrypt>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TestEncryptQueryResult = NonNullable<Awaited<ReturnType<typeof testEncrypt>>>
export type TestEncryptQueryError = unknown


export function useTestEncrypt<TData = Awaited<ReturnType<typeof testEncrypt>>, TError = unknown>(
 params: TestEncryptParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof testEncrypt>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof testEncrypt>>,
          TError,
          Awaited<ReturnType<typeof testEncrypt>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestEncrypt<TData = Awaited<ReturnType<typeof testEncrypt>>, TError = unknown>(
 params: TestEncryptParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testEncrypt>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof testEncrypt>>,
          TError,
          Awaited<ReturnType<typeof testEncrypt>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTestEncrypt<TData = Awaited<ReturnType<typeof testEncrypt>>, TError = unknown>(
 params: TestEncryptParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testEncrypt>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏïîÌò∏Ìôî ÌÖåÏä§Ìä∏
 */

export function useTestEncrypt<TData = Awaited<ReturnType<typeof testEncrypt>>, TError = unknown>(
 params: TestEncryptParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof testEncrypt>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTestEncryptQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÌäπÏ†ï Î∞∞Î≤àÏùò race_member_idÎ•º Ï∞æÏäµÎãàÎã§.
 * @summary Î∞∞Î≤àÏúºÎ°ú RaceMember ID Ï∞æÍ∏∞
 */
export const findRaceMemberByBib = (
    params: FindRaceMemberByBibParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/admin/migration/find-race-member-by-bib`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getFindRaceMemberByBibQueryKey = (params?: FindRaceMemberByBibParams,) => {
    return [
    `/api/v1/admin/migration/find-race-member-by-bib`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getFindRaceMemberByBibQueryOptions = <TData = Awaited<ReturnType<typeof findRaceMemberByBib>>, TError = unknown>(params: FindRaceMemberByBibParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findRaceMemberByBib>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindRaceMemberByBibQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findRaceMemberByBib>>> = ({ signal }) => findRaceMemberByBib(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findRaceMemberByBib>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindRaceMemberByBibQueryResult = NonNullable<Awaited<ReturnType<typeof findRaceMemberByBib>>>
export type FindRaceMemberByBibQueryError = unknown


export function useFindRaceMemberByBib<TData = Awaited<ReturnType<typeof findRaceMemberByBib>>, TError = unknown>(
 params: FindRaceMemberByBibParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findRaceMemberByBib>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findRaceMemberByBib>>,
          TError,
          Awaited<ReturnType<typeof findRaceMemberByBib>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindRaceMemberByBib<TData = Awaited<ReturnType<typeof findRaceMemberByBib>>, TError = unknown>(
 params: FindRaceMemberByBibParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findRaceMemberByBib>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findRaceMemberByBib>>,
          TError,
          Awaited<ReturnType<typeof findRaceMemberByBib>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindRaceMemberByBib<TData = Awaited<ReturnType<typeof findRaceMemberByBib>>, TError = unknown>(
 params: FindRaceMemberByBibParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findRaceMemberByBib>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î∞∞Î≤àÏúºÎ°ú RaceMember ID Ï∞æÍ∏∞
 */

export function useFindRaceMemberByBib<TData = Awaited<ReturnType<typeof findRaceMemberByBib>>, TError = unknown>(
 params: FindRaceMemberByBibParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findRaceMemberByBib>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindRaceMemberByBibQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÌäπÏ†ï Ìï¥ÏãúÍ∞íÏóê Ìï¥ÎãπÌïòÎäî Î∞∞Î≤àÏùÑ Ï∞æÏäµÎãàÎã§.
 * @summary Ìï¥ÏãúÎ°ú Î∞∞Î≤à Ï∞æÍ∏∞
 */
export const findBibByHash = (
    params: FindBibByHashParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/v1/admin/migration/find-bib-by-hash`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getFindBibByHashQueryKey = (params?: FindBibByHashParams,) => {
    return [
    `/api/v1/admin/migration/find-bib-by-hash`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getFindBibByHashQueryOptions = <TData = Awaited<ReturnType<typeof findBibByHash>>, TError = unknown>(params: FindBibByHashParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBibByHash>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindBibByHashQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findBibByHash>>> = ({ signal }) => findBibByHash(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findBibByHash>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindBibByHashQueryResult = NonNullable<Awaited<ReturnType<typeof findBibByHash>>>
export type FindBibByHashQueryError = unknown


export function useFindBibByHash<TData = Awaited<ReturnType<typeof findBibByHash>>, TError = unknown>(
 params: FindBibByHashParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBibByHash>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findBibByHash>>,
          TError,
          Awaited<ReturnType<typeof findBibByHash>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindBibByHash<TData = Awaited<ReturnType<typeof findBibByHash>>, TError = unknown>(
 params: FindBibByHashParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBibByHash>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findBibByHash>>,
          TError,
          Awaited<ReturnType<typeof findBibByHash>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindBibByHash<TData = Awaited<ReturnType<typeof findBibByHash>>, TError = unknown>(
 params: FindBibByHashParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBibByHash>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ìï¥ÏãúÎ°ú Î∞∞Î≤à Ï∞æÍ∏∞
 */

export function useFindBibByHash<TData = Awaited<ReturnType<typeof findBibByHash>>, TError = unknown>(
 params: FindBibByHashParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBibByHash>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindBibByHashQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




